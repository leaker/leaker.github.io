<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programing on 逃避虽然可耻但有用</title><link>https://www.leelib.com/categories/programing.html</link><description>Recent content in programing on 逃避虽然可耻但有用</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 17 Sep 2021 23:22:14 +0800</lastBuildDate><atom:link href="https://www.leelib.com/categories/programing/atom.xml" rel="self" type="application/rss+xml"/><item><title>记一些常用的CSS布局方式</title><link>https://www.leelib.com/2021/09/17/css-layout.html</link><pubDate>Fri, 17 Sep 2021 23:22:14 +0800</pubDate><guid>https://www.leelib.com/2021/09/17/css-layout.html</guid><description>内容部分占满页面的剩余高度 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Dock.Full&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; html, body, #full { color: #EFEFEF; background-color: #423F3E; margin: 0; padding: 0; height: 100%; } #full { background-color: #171010; display: flex; flex-direction: column; } #someid { background-color: #362222; flex-grow: 1; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;full&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;header&amp;#34;&amp;gt;Dock.Top&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;someid&amp;#34;&amp;gt;Dock.Full&amp;lt;/div&amp;gt;</description></item><item><title>Eclipse-ADT在Windows下添加library的BUG</title><link>https://www.leelib.com/2016/04/20/adt-add-library-bug.html</link><pubDate>Wed, 20 Apr 2016 18:35:35 +0800</pubDate><guid>https://www.leelib.com/2016/04/20/adt-add-library-bug.html</guid><description>问题出现 今天在Windows里使用 Cocos-Quick 创建的项目在使用ADT往Android里面部署的时候遇到了下面的问题 {% img /images/20160420/adt_add_library_bug.webp %} 出现上图的情况是这样的操作步</description></item><item><title>类 enable_shared_from_this 的经验总结</title><link>https://www.leelib.com/2015/12/13/enable-shared-from-this.html</link><pubDate>Sun, 13 Dec 2015 23:32:07 +0800</pubDate><guid>https://www.leelib.com/2015/12/13/enable-shared-from-this.html</guid><description>不能再构造函数内使用 shared_from_this() 函数 class class_a : public std::enable_shared_from_this&amp;lt;class_a&amp;gt; { public: class_a(void) { auto self(shared_from_this());// 这里会报 bad_weak_ptr 错误 } }; 子类无法重复继承 class class_a : public std::enable_shared_from_this&amp;lt;class_a&amp;gt; { }; class class_b : public class_a, public std::enable_shared_from_this&amp;lt;class_a&amp;gt; { }; 这段代码将无法通过编译。 如</description></item><item><title>VS2013静态编译openssl批处理</title><link>https://www.leelib.com/2015/09/14/vs2013-build-openssl-static.html</link><pubDate>Mon, 14 Sep 2015 12:26:46 +0800</pubDate><guid>https://www.leelib.com/2015/09/14/vs2013-build-openssl-static.html</guid><description>打开 Visual Studio 2013 Command Prompt wget http://www.nasm.us/pub/nasm/releasebuilds/2.11.08/win32/nasm-2.11.08-win32.zip unzip nasm-2.11.08-win32.zip -d C:/nasm set PATH=%PATH%;C:/nasm/ wget https://www.openssl.org/source/openssl-1.0.2d.tar.gz tar xzf openssl-1.0.2d.tar.gz cd openssl-1.0.2d perl configure VC-WIN32 --prefix=C:/openssl ms\do_nasm nmake -f ms\nt.mak nmake -f ms\nt.mak install echo &amp;#34;build successed.&amp;#34; 这样编译不会产生 error A2070:invalid instruction operands 这个错误</description></item><item><title>VS里std::max和max宏混淆问题的解决方案</title><link>https://www.leelib.com/2015/02/09/fix-std-max-error.html</link><pubDate>Mon, 09 Feb 2015 11:27:16 +0800</pubDate><guid>https://www.leelib.com/2015/02/09/fix-std-max-error.html</guid><description>有时,把旧项目转换成新版本项目时,旧版本项目里使用的 max 和 min 宏无法在新版本中正常编译. 原因是: 新版本内有了新的函数 std::max 和 std::min 函数来实现这一功能 这时</description></item><item><title>Windows下的DLL卸载本身模块的方法</title><link>https://www.leelib.com/2015/01/16/windows-dll-freelibrary-self.html</link><pubDate>Fri, 16 Jan 2015 01:35:37 +0800</pubDate><guid>https://www.leelib.com/2015/01/16/windows-dll-freelibrary-self.html</guid><description>在 Windows 里 DLL 卸载自身模块是无法通过字节调用 FreeLibrary 自己来实现的。 原因分析 在当前线程中调用 FreeLibrary 后，当前模块就会立即被释放掉，而当前线程还没有运行结束。所以</description></item><item><title>python代码简单加密解密工具</title><link>https://www.leelib.com/2014/11/21/python-simple-crypt-code.html</link><pubDate>Fri, 21 Nov 2014 19:13:45 +0800</pubDate><guid>https://www.leelib.com/2014/11/21/python-simple-crypt-code.html</guid><description>#!/usr/env python &amp;#34;&amp;#34;&amp;#34; :license: MIT Copyright (C) 2012 HustMoon Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &amp;#34;Software&amp;#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,</description></item><item><title>VS2013上直接使用ATL的注意事项</title><link>https://www.leelib.com/2014/11/21/vs2013-use-atl.html</link><pubDate>Fri, 21 Nov 2014 12:15:21 +0800</pubDate><guid>https://www.leelib.com/2014/11/21/vs2013-use-atl.html</guid><description>不再需要导入atl.lib库了，直接包含以下头文件就可以了 #include &amp;lt;atlbase.h&amp;gt;#include &amp;lt;atlcom.h&amp;gt;#include &amp;lt;atlctl.h&amp;gt;要使用 AtlAxAttachControl 等函数的话，则必须初始化ATL模块 CComModule</description></item><item><title>在使用boost库时发生 error C4996: 'std::_Copy_impl' 的解决方案</title><link>https://www.leelib.com/2013/11/23/boost-c4996-std-copy-impl.html</link><pubDate>Sat, 23 Nov 2013 13:21:44 +0800</pubDate><guid>https://www.leelib.com/2013/11/23/boost-c4996-std-copy-impl.html</guid><description>原本的程序是控制台的。 但最近需要移植到windows下使用。 所以以MFC来做UI，代码照搬。 一面的一处代码使用了如下语句： boost::split(v, data, boost::is_any_of(_T(&amp;#34;n&amp;#34;))); 结果编译时出</description></item><item><title>让Socket通过HTTP代理通讯</title><link>https://www.leelib.com/2013/10/29/make-socket-proxy.html</link><pubDate>Tue, 29 Oct 2013 16:06:54 +0800</pubDate><guid>https://www.leelib.com/2013/10/29/make-socket-proxy.html</guid><description>如果socket想使用HTTP代理，需要进行下面步骤： connect到代理服务器 send(Format(&amp;ldquo;CONNECT %s:%s HTTP/1.1rnUser-Agent: MyApp/0.1rnrn&amp;rdquo;, &amp;lt;真正目标IP&amp;gt;, &amp;lt;真正目标端口&amp;</description></item><item><title>自己使用过程中使用zlib链接时出的错误总结</title><link>https://www.leelib.com/2013/10/04/use-zlib.html</link><pubDate>Fri, 04 Oct 2013 06:37:29 +0800</pubDate><guid>https://www.leelib.com/2013/10/04/use-zlib.html</guid><description>错误1 error LNK2019: unresolved external symbol _deflateEnd@4 原因1: 未使用zlib的链接库 解决： #pragma comment(lib, &amp;#34;zlibstat.lib&amp;#34;) // for static lib #pragma comment(lib, &amp;#34;zdll.lib&amp;#34;) // for dll lib 原因2：在使用静态库时即使包含了zlibstat.lib没</description></item><item><title>error LNK2026: module unsafe for SAFESEH image 解决方案</title><link>https://www.leelib.com/2013/10/03/error-lnk2026-module-unsafe-for-safeseh-image.html</link><pubDate>Thu, 03 Oct 2013 15:21:16 +0800</pubDate><guid>https://www.leelib.com/2013/10/03/error-lnk2026-module-unsafe-for-safeseh-image.html</guid><description>解决方案 下面两种随便选一种 方法1 去掉项目设置中: Linker -&amp;gt; Advanced -&amp;gt; [Image Has Safe Exception Handlers] = &amp;ldquo;No&amp;rdquo; 方法2 直接在代码中: #pragma comment(linker, &amp;#34;/SAFESEH:NO&amp;#34;)</description></item><item><title>如何用正确的 C 运行时 (CRT) 库链接</title><link>https://www.leelib.com/2013/10/03/how-to-use-crt.html</link><pubDate>Thu, 03 Oct 2013 04:13:52 +0800</pubDate><guid>https://www.leelib.com/2013/10/03/how-to-use-crt.html</guid><description>概要 有六种类型的可重用的库： 静态单线程库 （调试/发行版） 静态多线程的库 （调试/发行版） 动态链接库 (DLL)(Debug/Release) 注意每个库都有一个调试版本和发布版本。 Reusable Library</description></item><item><title>python的zlib压缩解压缩对应的C语言方式</title><link>https://www.leelib.com/2013/07/02/python-zlib-trans-c.html</link><pubDate>Tue, 02 Jul 2013 15:47:00 +0800</pubDate><guid>https://www.leelib.com/2013/07/02/python-zlib-trans-c.html</guid><description>压缩 enData = zlib.compress(data)[2:-4] 对应： compress2(dstbuf, &amp;amp;dstLen, strSrc, srcLen, 6); 解压 deData = zlib.decompress(enData, -zlib.MAX_WBITS) 对应： bool gzipInflate( const std::string&amp;amp; compressedBytes, std::string&amp;amp; uncompressedBytes ) { if ( compressedBytes.size() == 0 ) { uncompressedBytes = compressedBytes ; return true ; } uncompressedBytes.clear() ; unsigned full_length = compressedBytes.size() ; unsigned half_length = compressedBytes.size() / 2; unsigned uncompLength = full_length ; char* uncomp = (char*) calloc( sizeof(char),</description></item><item><title>Windows下编译使用zlib库的程序时出现“无法解析的外部符号 _compress”解决方案</title><link>https://www.leelib.com/2013/07/01/windows-use-zlib-link-error.html</link><pubDate>Mon, 01 Jul 2013 05:29:47 +0800</pubDate><guid>https://www.leelib.com/2013/07/01/windows-use-zlib-link-error.html</guid><description>错误描述 error LNK2019: unresolved external symbol _compress referenced 解决方案 在 #include &amp;lt;zlib.h&amp;gt; 之前加上 #define ZLIB_WINAPI #define ZLIB_WINAPI #include &amp;lt;zlib.h&amp;gt;</description></item><item><title>一句话经验zlib</title><link>https://www.leelib.com/2013/06/29/use-zlib-exp.html</link><pubDate>Sat, 29 Jun 2013 04:27:00 +0800</pubDate><guid>https://www.leelib.com/2013/06/29/use-zlib-exp.html</guid><description>Linux使用gcc编译使用zlib库的代码时，使用 -lz 来链接(link) zlib 库。 否则就会出现类似 undefined reference to `deflateInit_&amp;rsquo; 的错误</description></item><item><title>gcc迁移到g++出现 inet_addr was not declared in this scope 解决方案</title><link>https://www.leelib.com/2013/06/07/gcc-to-gpp-inet-addr-was-not-declared-in-this-scope.html</link><pubDate>Fri, 07 Jun 2013 14:06:31 +0800</pubDate><guid>https://www.leelib.com/2013/06/07/gcc-to-gpp-inet-addr-was-not-declared-in-this-scope.html</guid><description>错误原因 我手上一个项目本身采用gcc编译。后来因为代码功能需要移植到g++中时，出现了 &amp;ldquo;inet_addr&amp;rdquo; was not declared in this scope 这个错误。 解决方案 // 添加该头文件 #include &amp;lt</description></item><item><title>解决VS2012编译的程序在WinXP上运行异常</title><link>https://www.leelib.com/2013/05/29/vs2012-build-app-run-in-winxp-failed.html</link><pubDate>Wed, 29 May 2013 02:50:35 +0800</pubDate><guid>https://www.leelib.com/2013/05/29/vs2012-build-app-run-in-winxp-failed.html</guid><description>在写代码的过程中,我发现使用VS2012编译出来的程序默认支持的系统版本略高 刚发现在 Win7+VS2012 编译出来的程序默认PE信息(Optional Header): Major SubSystem Version =</description></item><item><title>boost的编译与安装</title><link>https://www.leelib.com/2013/05/27/compile-boost.html</link><pubDate>Mon, 27 May 2013 09:31:57 +0800</pubDate><guid>https://www.leelib.com/2013/05/27/compile-boost.html</guid><description>Windows下编译安装 生成bjam bootstrap.bat 编译 bjam --toolset=msvc-11.0 --build-type=complete 安装 bjam --prefix=D:\third_party\boost install Ubuntu仅安装开发包 sudo apt-get install -y libboost-dev libboost-system-dev</description></item><item><title>生成不重复的随机数</title><link>https://www.leelib.com/2013/03/15/no-repeat-random-num.html</link><pubDate>Fri, 15 Mar 2013 13:47:47 +0800</pubDate><guid>https://www.leelib.com/2013/03/15/no-repeat-random-num.html</guid><description>下面代码就可以生成1-100区间的随机数： #include &amp;lt;vector&amp;gt;#include &amp;lt;algorithms&amp;gt; std::vector&amp;lt;int&amp;gt; random_numbers; for (unsigned int i = 0; i &amp;lt; 100; ++i) random_numbers.push_back(i + 1); std::random_shuffle(random_numbers.begin(), random_numbers.end());</description></item><item><title>使CMake生成工程采用相对路径</title><link>https://www.leelib.com/2012/05/16/cmake-use-relative-path.html</link><pubDate>Wed, 16 May 2012 03:18:15 +0800</pubDate><guid>https://www.leelib.com/2012/05/16/cmake-use-relative-path.html</guid><description>解决方案 在生成项目之前勾选上 CMAKE_USE_RELATIVE_PATHS 这个选项，效果如上图所示。</description></item><item><title>汇编中ROL(循环左移)对应的C语言实现</title><link>https://www.leelib.com/2012/04/24/asm-rol-to-c.html</link><pubDate>Tue, 24 Apr 2012 10:48:29 +0800</pubDate><guid>https://www.leelib.com/2012/04/24/asm-rol-to-c.html</guid><description>在汇编语言中，我们可以直接使用ROL ROR等指令进行循环左移和循环右移的操作。 但C语言中却没有对应的操作，没办法只能自己实现了。 下面是我最近</description></item><item><title>将M8导出的联系人XML转化成Andriod可以导入的vcf文件</title><link>https://www.leelib.com/2012/04/12/convert-m8-contacts-xml-to-andriod-vcf.html</link><pubDate>Thu, 12 Apr 2012 09:27:17 +0800</pubDate><guid>https://www.leelib.com/2012/04/12/convert-m8-contacts-xml-to-andriod-vcf.html</guid><description>通过我写的一段Python代码可以让M8用户将联系人导入到Andriod系统中。 操作需要以下步骤： 先用M8PC工具将M8的联系人导出成XML</description></item></channel></rss>